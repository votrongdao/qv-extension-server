using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.ServiceProcess;
using System.Threading;
using Timers = System.Timers;

using System.IO;
using System.IO.Pipes;

using CapCore = myQvCap.Core;
using CapWeb = myQvCap.Web;
using CapThread = myQvCap.Threading;


namespace myQvCap.Service
{
    public delegate void WSNotificationEventHandler (object sender, WSNotificationEventArgs e);

    public class WSNotificationEventArgs : EventArgs
    {
        public Object msg;

        public WSNotificationEventArgs() : base() { }
        public WSNotificationEventArgs(Object msg)
            : base()
        {
            this.msg = msg;
        }

    }

    public abstract class AService
    {
        private bool initialized = false;
        private bool started = false;
        private bool hasWS = false;

        public CapWeb.HostWorker WSHostWorkerObject = null;
        public Thread WSHostWorkerThread = null;
        public Thread clientPipeWorkerThread = null;
        public CapThread.PipeServer WSPipe = null;

        private string serviceName = null;

        public event WSNotificationEventHandler WSNotification;

        protected virtual void OnWSNotification(WSNotificationEventArgs e)
        {
            if (WSNotification != null)
                WSNotification(this, e);
        }

        public void init(string serviceName, params object[] args)
        {
            this.serviceName = serviceName;
            this.initialized = true;

            this.toInit(args);
        }

        protected abstract void toInit(params object[] args);

        public void start(bool hasWS, int port, List<string> nsNames)
        {
            if (!this.initialized) throw new Exception("Service must be initialized before being started ...");

            this.started = true;
            this.hasWS = hasWS;

            CapCore.Logging.log("Service starting ...", CapCore.LogType.Information, 0);

            if (this.hasWS)
            {
                WSPipe = new CapThread.PipeServer(this.serviceName);
                WSPipe.NewMessage += new CapThread.NewMessageEventHandler(WSPipe_NewMessage);

                CapWeb.HttpListenerWrapper lw = CapWeb.HttpListenerWrapper.GetWrapper(port, nsNames);
                lw.Start();

                CapCore.Logging.log("Listening for requests on port " + port.ToString() + " on localhost, 127.0.0.1" + ((nsNames != null && nsNames.Count > 0) ? ", " + String.Join(", ", nsNames.ToArray()) : "") + " ...", CapCore.LogType.Information, 1);

                this.WSHostWorkerObject = new CapWeb.HostWorker();
                this.WSHostWorkerThread = new Thread(this.WSHostWorkerObject.DoWork);

                this.WSHostWorkerThread.Start(lw);
            }

            this.toStart();
        }

        public List<CapCore.Tuple<T, Guid>> getQueueItems<T>()
        {
            CapCore.Logging.log("Get item from pipe queue requested ...", myQvCap.Core.LogType.Information, 11);
            return this.WSPipe.readObjects<T>();
        }

        public void putQueueItem<T>(T o, Guid g)
        {
            CapCore.Logging.log("Put item into pipe queue requested ...", myQvCap.Core.LogType.Information, 11);
            this.WSPipe.WriteObject<T>(o, g);
        }

        void WSPipe_NewMessage(object sender, CapThread.PipeEventArgs e)
        {
            WSNotificationEventArgs args = new WSNotificationEventArgs();
            this.OnWSNotification(args);
        }

        protected abstract void toStart();

        public void stop()
        {
            if (!this.started) throw new Exception("Service must be started before being stoped ...");

            CapCore.Logging.log("Service stopping ...", CapCore.LogType.Information, 0);

            if (this.hasWS)
            {
                WSHostWorkerObject.RequestStop();
                WSHostWorkerThread.Join();
            }

            this.toStop();
        }

        protected abstract void toStop();

    }
}
